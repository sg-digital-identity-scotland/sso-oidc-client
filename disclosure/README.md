# OIDC Spring Boot private client

## Introduction

This project contains the code to build and run an OIDC private client with 
Gradle and Spring Boot. 
It depends on [Spring Security OIDC OAuth2 client](https://docs.spring.io/spring-security/site/docs/5.2.12.RELEASE/reference/html/oauth2.html).

## Background

DIS authorization server supports standard authorization code flow with PKCE.

[OIDC core](https://openid.net/specs/openid-connect-core-1_0.html)

[PKCE](https://datatracker.ietf.org/doc/html/rfc7636)

This OIDC private client is what the standard calls "Relying Party". 
As a private client, it consists in a backend application running a web server.
It serves a page with links to initiate authorization requests and performs 
token exchange via back-channel request.

## Pre-requisites

### IP whitelisting

DIS authorization server only accepts incoming requests from whitelisted IPs.
You need to communicate to the DIS team the IP addresses of:
- every machine consuming the client: the authorization request is initiated 
from a browser on an end user machine
- every machine running the client: the token exchange is done via back-channel 
request by the backend application

### Progams

Building and running the client with Gradle should work with Java 11 and above.
It was successfully tested with Java 11 and 17.

There is a script to run in Docker, which requires... Docker.

DIS authorization server only supports private_key_jwt token authentication.
It expects the client to provide a public key on registration and sign a JWT 
using the public / private key pair on token exchange.
Given a key pair as environment variable, the client automatically signs the 
JWT and adds it to the token request.
There is a convenience script to generate the JWK key pair. It requires Java 14 
or above.

## Files structure

This project follows canonical Gradle files structure with some additional 
files and directories:
- `lib/` contains extra dependencies unrelated to build dependencies.
  - `json-web-key-generator.jar` used by script to generate JWK key pair.
- `scripts/` contains a set of scripts to build and run the code and perform 
other operations required by OIDC standard.
- `registration/` contains a set of files with client registration properties. 
See below.
- `env` populate this file with key / value pairs of environment variables to 
pass at runtime.

## Instructions

### 1 Client registration

Client registration requires the following mandatory parameters:
- `CLIENT_NAME`: name of the client. It is displayed in the DIS sign-up journey
before redirecting back to relying party.
- `REDIRECT_URI`: URL to redirect user agent to after DIS authentication. DIS 
redirects to this url with an authorization code for the relying party to 
perform token exchange.
Important:
  - When using this client the path of the redirect uri is mandated by the 
  Spring OAuth2 client library and must end in `/login/oauth2/code`.
  - DIS only accepts redirect uri with https scheme and host different than
  localhost. For local development we recommend adding an virtual host to your 
  `/etc/hosts` and register `https://{VIRTUAL_HOST}:{PORT}/login/oauth2/code`
- `JWK_PUBLIC_KEY`: DIS only supports private_key_jwt authentication on the 
token endpoint. Such authentication requires a public key be added to the 
registration payload. 
You can generate a public key and public / private key pair by running 
`scripts/generate_jwk.sh`. The script generates the corresponding files in a 
`registration/` directory. 
You keep the key pair `jwk_keypair.json` and you only share the public key 
`jwk_public_key.json` DIS for registration.

Client self-service registration is disabled. You can send the client 
registration parameters to the DIS team who will register the client on your 
behalf.

Once registered, the DIS team will reply with the client id generated by the 
authorization server. This client id must be store in a `registration/client`
file as key / value pair `DIS_CLIENT_ID=${DIS_CLIENT_ID}`.

Please also update the values for `HOST` and `PORT` in the `env` file with the values you used during client registration.

### 2 Generate key store

As mentioned in the client registration section, DIS only supports https scheme 
for client registration redirect uri. As such the client needs to run on https.
`scripts/generate_keystore.sh` is a convenience script to generate a keystore 
and save the file under `src/main/resources`. 
It reads its input parameters from `env`. 
The same input parameters are read as environment variables at runtime to 
resolve the keystore to consume. 
At the moment the keystore must be generated before a build, the runtime does 
not support reading keystore from an arbitrary file. As a consequence you need
to build the client again if you change keystore.

### 3 Build

There are some convenience scripts to build the code.
- `scripts/build_gradle.sh`: Gradle clean and build
- `scripts/build_docker.sh`: build Docker image using jib. 
It uses a minimized base image from `gcr.io/distroless/java11-debian11` 
repository. The distroless project offers debug images in case you need to run 
utilities in the container for debugging purposes. The base image can be changed
in the `jib` task in the `build.gradle` script.

Usage: 
`./scripts/build_docker.sh --IMAGE_NAME ${IMAGE_NAME} --IMAGE_TAG ${IMAGE_TAG}`

Both options `IMAGE_NAME` and `IMAGE_TAG` are optional.
By default `IMAGE_NAME` equals project name set in `settings.gradle` and 
`IMAGE_TAG` equals `1.0.0`.

### 4 Run

There are some convenience scripts to run the build artifacts.
- `scripts/run_gradle.sh`: Gradle run
- `scripts/run_docker.sh`: run Docker container using image built in previous 
step. It applied the same defaults. 

Usage:
`./scripts/run_docker.sh --IMAGE_NAME ${IMAGE_NAME} --IMAGE_TAG ${IMAGE_TAG}`

Both options `IMAGE_NAME` and `IMAGE_TAG` are optional.
Both scripts source environment variables from `env` and client registration 
parameters from `registration/client` before running the client.

## Using the client

The client runs on `https://${HOST}:${PORT}`. `HOST` and `PORT` set in `env`.
When running locally, because of the https scheme, the browser may initially 
display a `NET::ERR_CERT_AUTHORITY_INVALID` warning. It can be safely ignored 
and the client's homepage can be accessed by clicking on 
"Advanced -> Proceed to ${HOST} (unsafe)" or similar.

The client's homepage displays two links, one to Sign Up and one to Sign In. 

### Sign Up / Sign In

Clicking `Sign In` and completing the journey authenticates an existing user on 
the DIS sandbox environment. 
Clicking `Sign Up` and completing the journey creates a user and automatically 
authenticates the user on the DIS sandbox environment. 

From `Sign In`, it is possible to navigate to the recovery page where a user can 
recover authentication factors.

Once a user is succesfully authenticated, the DIS authorization server redirects 
back to the private client with an authorization code. The client performs token
exchange in a back-channel request. On success the authorization server issues 
an id token, the client reads the token, extracts sub claim from it, redirects 
to home page and displays the sub claim under the Sign In and Sign Up links.  

Once authenticated, the user is in session from the DIS point of view.
Clicking again `Sign In` or `Sign Up` will look like nothing happens, although 
the user agent loads the DIS authorization endpoint, which identifies the 
subject session cookie to a user in session and automatically redirects back 
to the client.
Users can manually sign out to trigger authentication by deleting the `sub_sid` cookie
from the `authz.swan.sign-in.service.gov.scot` domain in the browser. An example of how
to do this in chrome would be to open the following chrome settings
`chrome://settings/siteData?searchSubpage=authz&search=cookies` and delete that cookie.

### Logout

There are three variables in the `.env` file which relate to logout:
- `DIS_END_SESSION_URI` is the logout endpoint on the authorization server.
- `POST_LOGOUT_REDIRECT_URI` is the endpoint the user is redirected to on the private client,
 after a succesful logout request.
- `BACKCHANNEL_LOGOUT_URI` is an endpoint on the private client, that is sent a post request
every time a user logs out.

Clicking `Logout` will log the user out from the client on the DIS authorization server.
After a successful logout, the user is redirected to the `POST_LOGOUT_REDIRECT_URI`.
This private client application has been set up with some basic default behaviour to
demonstrate the endpoints being called:

- On authorization of a user, a `SESSION` cookie is stored on the private
client's domain.
- On redirection of the a user to the `POST_LOGOUT_REDIRECT_URI` after logout, the `SESSION`
cookie is cleared and the user is redirected back to the home page.
- The home page no longer displays the logout button and subject session Id. This is because
clearing the session has removed them from the `@AuthenticationPrincipal` object.

After logging out, if a user were to `Sign In` or `Sign Up` again, then they would not be 
asked to re-authenticate again. This is because they still have a valid subject session 
cookie on the authorization server, so will be redirected back to the client with an authorization
code.

The `BACKCHANNEL_LOGOUT_URI` is called every time a user logs out from the client. On a succesful
logout, the user is redirected to the `POST_LOGOUT_REDIRECT_URI` AND a post request is sent to the
`BACKCHANNEL_LOGOUT_URI` from the authorization server.

The `BACKCHANNEL_LOGOUT_URI` must respond with a 200 OK to confirm to the authorization server that
they have received the request. The response should also include a `Cache-Control: no-store` header
to prevent the response from interfering with future logout requests

If the private client is running on localhost with a virtual domain, it will not be possible
for the authorization server to call any endpoints on the private client. This means the post request
to the `BACKCHANNEL_LOGOUT_URI` will not work. Therefore this endpoint would need to be called manually.


## Notes

The client works locally, but it does not support running behind a proxy. 
Spring security library does not support custom http client to make requests to 
OIDC endpoints and therefore it is not possible to configure a http proxy. 
If you need to run behind a proxy please contact the DIS team.
